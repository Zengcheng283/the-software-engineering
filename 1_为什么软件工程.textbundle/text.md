# 1_为什么软件工程

在本章中，可以了解到：
软件工程是什么意思
软件工程的跟踪记录
好软件是什么意思
为什么系统方法很重要
自20世纪70年代以来，软件工程发生了怎样的变化

## 1.1_什么是软件工程（What is Software Engineering）

作为软件工程师，我们利用我们的计算机和计算知识来帮助解决问题。
		我们处理的问题通常与计算机或现有计算机系统有关，但有时问题背后的困难与计算机无关。
		因此，我们必须首先了解问题的性质。特别是，我们必须非常小心，不要将计算机器或技术强加给我们遇到的每一个问题。
		我们必须先解决这个问题。然后，如果需要，我们可以使用技术作为实现解决方案的工具。

### 1.1.1_解决问题（Solving Problems）

大多数问题都很大，有时很难处理，尤其是当它们代表了一些以前从未解决过的新问题时。
		因此，我们必须通过分析（analyzing）问题来开始调查，也就是说，将问题分解成我们能够理解并试图处理的部分。
		因此，我们可以将较大的问题描述为小问题及其相互关系的集合。
		重要的是要记住，关系与子问题本身一样重要。有时，正是关系为解决更大的问题提供了线索，而不仅仅是子问题的性质。

### 1.1.2_软件工程师适合哪里（Where Does the Software Engineer Fit In?）

软件工程师将计算机的功能作为通用解决方案的一部分，而不是计算机本身的结构或理论。

## 1.2_我们有多成功（How Successful Have We Been?）

## 1.3_什么是好的软件（What is Good Software?）

正如制造商寻求确保其生产的产品质量的方法一样，软件工程师也必须找到方法来确保他们的产品是可接受的质量和实用性。
		因此，好的软件工程必须始终包括一种生产高质量软件的策略。
		在安全关键或任务关键系统中，文字处理软件中允许的故障可能是不可接受的。
		因此，我们必须至少从三个方面考虑质量：产品的质量、产生产品的过程的质量，以及在使用产品的商业环境中的产品质量。

### 1.3.1_产品质量（The Quality of the Product）

- 可靠性（Reliability）
- 可用性（Usability）
- 可测试性（Testability）
- 效率（Efficiency）
- 可维护性（Maintainability）
- 正确性（Correctness）

### 1.3.2_进程质量（The Quality of the Process）

影响最终产品质量的活动很多，如果任何活动出错，产品质量可能会受到影响。
		因此，许多软件工程师认为开发和维护过程的质量与产品质量一样重要。对流程进行建模的优点之一是，我们可以对其进行检查并寻找改进的方法。
		例如，我们可以提出以下问题：
我们可能在何时何地发现特定类型的故障？
我们如何在开发过程的早期发现故障？
我们如何构建容错能力，以便减小错误变成失败的可能性吗？
我们如何设计安全、高质量的系统？
是否有其他活动可以使我们的流程更有效或更高效地确保质量？

### 1.3.3_商业环境中的质量（Quality in the Context of the Business Environment）

当质量评估的重点是产品和过程时，我们通常用涉及错误、失败和时间的数学表达式来衡量质量，很少将范围扩大到包括业务角度，即从嵌入软件的业务所提供的产品和服务的角度来看待质量。
		也就是说，我们着眼于产品的技术价值，而不是更广泛地着眼于产品的商业价值，我们只根据最终产品的技术质量做出决策。换句话说，我们应该想办法将技术质量提高，并自动转化为业务价值。

## 1.4_谁来进行软件工程（Who Does Software Engineering?）

通常，项目的参与者分为三类：客户、用户或开发人员。
		客户（customer）是指为要开发的软件系统付费的公司、组织或个人。
		开发人员（developer）是为客户构建软件系统的公司、组织或个人。该类别包括协调和指导程序员和测试人员所需的任何经理。
		用户（user）是实际使用系统的人：坐在终端或提交数据或读取输出的人。
		虽然对于某些项目，客户、用户和开发人员是同一个人或组，但通常是不同的人。
		近年来，客户、用户和开发人员之间的简单区别变得更加复杂。客户和用户以各种方式参与到开发过程中。客户可能会决定购买商用现货（Commercial Off-The-Shelf）（COTS）软件，以获得开发人员将提供和支持的最终产品中。
		当这种情况发生时，客户将参与到系统架构决策中，并且在开发中有更多的限制。同样，开发人员可以选择使用其他开发人员，称为分包商（subcontractors），他们构建子系统并将其交付给开发人员，这些子系统将包含在最终产品中。
		分包商可以与主要开发商并肩工作，也可以在不同的地点工作，与主要开发商协调工作，并在开发过程的后期交付子系统。
		子系统可以是完整可立即使用的系统（turnkey system），其中代码为整合整体（无需额外的集成代码），或者可能需要一个单独的集成过程来构建从主要系统到子系统的链接。

## 1.5_系统方法（A Systems Approach）

我们开发的项目并非单独存在。通常，我们组合在一起的硬件和软件必须与用户、其他软件任务、其他硬件、现有数据库（即精心定义的数据集和数据关系）甚至其他计算机系统进行交互。
		因此，通过为任何项目提供一个环境从而了解项目的边界（boundaries）是很重要的：项目中包括什么，不包括什么。
		通常，我们的系统定义包括每个活动所需的输入、采取的行动和产生的输出列表。因此，首先，我们必须知道系统中是否包含任何对象或活动。

### 1.5.1_系统元素（The Elements of a System）

- 1.5.1.1_活动和对象（Activities and Objects）

  活动（activity）是系统中发生的事情。通常被描述为由触发器启动的事件，活动通过改变特征将一个事件转换为另一个事件。
  		而活动中涉及的元素称为对象（objects）或实体（entities）。通常，这些对象以某种方式相互关联。

- 1.5.1.2_关系和系统边界（Relationships and the System Boundary）

  一旦定义了实体和活动，我们就会将实体与其活动进行匹配。
  		实体和活动之间的关系得到了明确而仔细的定义。
  		实体定义包括实体来源的描述。某些项目位于已存在的文件中，另一些则是在某些活动中产生的。
  		实体的目的地也很重要。
  		某些项目仅由一个活动使用，但其他项目需要输入到其他系统。也就是说，一个系统中的某些项目需要被正在检查的系统范围之外的其他活动使用。
  		因此，我们可以认为我们正在寻找的系统有一个或多个边界。一些项目跨越边界进入我们的系统，其他项目是我们系统的产品，并用于其他系统。
  		使用这些概念，我们可以将系统（system）定义为事物的集合：一组实体、一组活动、实体和活动之间关系的描述以及系统边界的定义。
  		系统的这个定义不仅适用于计算机系统，而且适用于对象以某种方式与其他对象交互的任何事物。

- 1.5.1.3_系统样例（Examples of Systems）

  我们也必须清楚地描述我们的计算机系统。我们与潜在用户一起定义系统的边界：我们的工作从哪里开始和停止？
  		此外，我们需要知道系统边界上的内容，从而确定输入的来源和输出的目的地。

### 1.5.2_相互关联的系统（Interrelated Systems）

当需要对旧手工版本系统A进行重构来构建全新的自动化系统B时，可能因为两者之间的差异过大导致人们出现不愿意更改或者学习困难的问题。
		此时，进行增量形式转变对解决这种困难很有用。若A有三个主要功能，那么对三个功能进行分步转变会比一次性转变更容易达到。
		最后，B具有所有三个自动化功能。通过将A到B的“距离”除以三分之一，我们就有了一系列小问题，这些小问题可能比整体问题更容易处理。
		在这个例子中，这两个系统非常相似，这些函数是相同的，但实现它们的样式不同。
		然而，目标系统通常与现有系统有很大不同。尤其是，通常希望目标不受现有硬件或软件的限制。
		增量开发（incremental development）方法可能包含一系列阶段，每个阶段都将以前的系统从另一个此类约束中解放出来。
		例如，阶段1可以添加新的硬件，阶段2可以替换执行特定功能集的软件，等等。系统逐渐脱离旧的软件和硬件，直到它反映出新的系统设计。

## 1.6_工程方法（An Engineering Approach）

因为构建一个系统类似于构建一座房子，所以我们可以通过构建房子来了解为什么软件开发的“艺术”方法很重要。

### 1.6.1_建房子（Building a House）

让我们更仔细地看看这一进程涉及到什么。
		首先，由于许多人同时在这所房子上工作，所以文档是必不可少的。不仅需要平面图和建筑师的图纸，而且还必须写下细节，以便水管工和电工等专业人员能够在房子成为一个整体时将其产品装配在一起。
		其次，期望豪厄尔一家在过程开始时描述他们的房子，然后一直可以顺利进行到房子完工为止，这是不合理的。相反，豪厄尔夫妇可能会在施工期间多次修改房屋设计。这些修改可能由多种情况引起：
最初指定的材料不再可用。例如，某些类型的屋顶砖可能不再生产。
豪厄尔一家在看到房子成型时可能会有新想法。
可用性或财务限制可能要求豪厄尔家族改变需求，以满足其计划或预算。
最初认为可能的项目或设计可能不可行。
		再者，McMullen必须提供蓝图、接线图和管道图、设备的说明手册，以及任何其他文件，以便豪厄尔夫妇在搬入后进行修改或维修。

- 确定和分析需求
- 制作并记录房屋的总体设计
- 制定房屋的详细规格
- 识别和设计组件
- 建造房屋的每个组件
- 测试房屋的每个组件
- 居民入住后，整合组件并进行最终修改
- 房屋居民持续维护

### 1.6.2_创建系统（Building a System）

软件项目的进度类似于房屋建造过程。豪厄尔夫妇是客户和用户，麦克马伦是我们示例中的开发人员。如果豪厄尔一家让麦克马伦为豪厄尔的父母建造房子，那么用户、客户和开发商将是不同的。
		同样，软件开发涉及用户、客户和开发人员。如果要求我们为客户开发软件系统，第一步是与客户会面以确定需求。正如我们之前看到的，这些需求描述了系统。如果不知道边界、实体和活动，就不可能描述软件及其与环境的交互方式。
		一旦定义了需求，我们就会进行系统设计来满足指定的需求，系统设计向客户展示了从客户的角度来看系统的样子。因此，正如豪厄尔夫妇查看平面图和建筑师图纸一样，我们向客户展示了将要使用的视频显示屏的图片、将生成的报告以及解释用户将如何与完整系统交互的任何其他描述。
		如果系统有手动备份或覆盖程序，也会对这些程序进行说明。
		起初，豪厄尔夫妇只对房子的外观和功能感兴趣，直到后来，他们才决定购买铜管或塑料管等物品。同样，软件项目的系统设计（也称为架构）阶段仅描述外观和功能。
		然后由客户审查设计。批准后，总体系统设计用于生成所涉及的各个程序的设计。请注意，直到这一步才提到程序。在确定功能和外观之前，考虑编码通常是没有意义的。
		在我们的房子示例中，我们准备讨论管道类型或电线质量。我们可以选择塑料管或铜管，因为现在我们知道水需要在结构中流向何处。
		同样，当系统设计得到所有人的批准时，我们准备讨论程序。
		我们讨论的基础是对软件项目作为一个系统的明确描述，系统设计包括对所涉及的功能和交互的完整描述。
		程序编写完成后，将作为单独的代码进行测试，然后才能将其链接在一起。
		测试的第一阶段称为模块或单元测试。一旦我们确信这些部件能够按预期工作，我们就将它们组合在一起，确保它们与其他部件连接时能够正常工作。
		第二个测试阶段通常被称为集成测试，因为我们通过在下一个阶段添加一个部分来构建我们的系统，直到整个系统都可以运行。
		最后的测试阶段称为系统测试，涉及整个系统的测试，以确保最初指定的功能和交互已正确实现。在此阶段，将系统与规定的要求进行比较，开发人员、客户和用户检查系统是否达到预期目的。
		最后，最终产品交付。
		在使用时，会发现差异和问题。如果我们的系统是完整即可用系统，则客户在交付后对系统负责。
		然而，许多系统并不是完整即可用系统，如果出现任何问题或需求发生变化，开发人员或其他组织都会提供维护。
		当编写和测试代码时，您可能会发现设备的功能与其文档中描述的不同。您可能需要重新设计代码，重新考虑系统设计，甚至与客户讨论如何满足需求。
		因此，我们将软件开发过程（software development process）定义为对软件开发的任何描述，其中包含开发过程九项的一些部分，并进行组织，以便它们一起生成经过测试的代码。

- 需求分析和定义（Requirements Analysis and Definition）
- 系统设计（System Design）
- 项目设计（Program Design）
- 编写程序/程序实现（Writing the Programs /Program Implementation）
- 单元测试（Unit Testing）
- 集成测试（Integration Testing）
- 系统测试（System Testing）
- 系统交付（System Delivery）
- 维护（Maintenance）

## 1.7_开发团队成员（Members of the Development Team）

### 需求分析师（Requirements Analyst）

开发团队包括一名或多名需求分析师与客户合作，将客户的整体需求分解为子需求。

### 设计师（Designer）

在完成需求分解记录后，分析人员就会与设计师合作，生成系统要执行的操作系统级描述。

### 程序员（Programmer）

设计师与程序员合作，以使得程序员能够编写实现指定内容需求的代码行。

### 测试人员（Tester）

生成代码后，必须对其进行测试。
		通常，第一次测试由程序员自己，有时，也会使用额外的测试人员来帮助捕获程序员忽视的错误。
		当代码单元集成到功能组后，一组测试人员与实现团队合作，以验证由多个部件组合而成的系统，工作正常，符合规范要求。

### 客户（Customer）

测试团队和客户一起工作，通过比较系统与初始需求集的工作方式以验证完整的系统是客户想要的来实现这一点。

### 培训师（Trainer）

培训师向用户展示如何使用系统。

### 维护团队（Maintenance Team）

如果在系统验收后发现故障，则由维护团队进行修复。
		此外，随着时间的推移，客户的要求可能会发生变化，必须对系统进行相应的更改。
		因此，维护可以包括确定添加或更改了哪些需求的分析员、确定应该在系统设计中的何处进行更改的设计人员、实施更改的程序员、确保更改后的系统仍然正常运行的测试人员，以及向用户解释更改如何影响系统使用的培训师。

- 需求分析师（Requirements Analyst）

  开发团队包括一名或多名需求分析师与客户合作，将客户的整体需求分解为子需求。

- 设计师（Designer）

  在完成需求分解记录后，分析人员就会与设计师合作，生成系统要执行的操作系统级描述。

- 程序员（Programmer）

  设计师与程序员合作，以使得程序员能够编写实现指定内容需求的代码行。

- 测试人员（Tester）

  生成代码后，必须对其进行测试。
  		通常，第一次测试由程序员自己，有时，也会使用额外的测试人员来帮助捕获程序员忽视的错误。
  		当代码单元集成到功能组后，一组测试人员与实现团队合作，以验证由多个部件组合而成的系统，工作正常，符合规范要求。

- 培训师（Trainer）

  培训师向用户展示如何使用系统。

### 图书馆员（Librarian）

图书馆员负责存储系统生命周期内使用的文档，包括需求规范、设计说明、程序文档、培训手册、测试数据、时间表等。

### 配置管理团队（Configuration Management Team）

配置管理涉及维护需求、设计、实现和测试之间的对应关系。
		这种交叉引用告诉开发人员，如果需要更改需求，应该更改什么程序，或者如果提出某种更改，程序的哪些部分将受到影响。
		配置管理人员还协调可能构建和支持的系统的不同版本。

## 1.8_软件工程如何改变的（How Has Software Engineering Changed?）

### 1.8.1_转变性质（The Nature of the Change）

早期的应用程序打算在单个处理器上运行，通常是大型机。输入是线性的，通常是一副卡片或一条输入磁带，而输出为字母数字。
		该系统的设计有两种基本方式：作为转换，其中输入转换为输出；或作为事务，其中输入确定将执行哪个功能。		
		当今基于软件的系统截然不同，更复杂。通常，它们运行在多个系统上，有时在具有分布式功能的客户机-服务器体系结构中配置。
		软件不仅执行用户需要的主要功能，还执行网络控制，安全性、用户界面表示和处理以及数据或对象管理。

- 商业产品上市时间的关键性
- 计算经济的转变：降低硬件成本，提高开发和维护成本
- 强大桌面计算的可用性
- 广泛的局域网和广域网
- 面向对象技术的可用性和采用
- 使用窗口、图标、菜单和指针的图形用户界面
- 软件开发瀑布模型的不可预测性

### 1.8.2_瓦瑟曼的软件工程学科（Wasserman’s Discipline of Software Engineering）

- 抽象（Abstraction）

  抽象（abstraction）是在某种程度上概括问题的描述，使我们能够专注于关键问题的各个方面而非陷入细节。
  		这个概念不同于转换（transformation），在转换中，我们将问题转换到我们更了解的另一个环境中。
  		转换通常用于将问题从现实世界转移到数学世界，因此我们可以操纵数字来解决问题。

- 分析和设计方法及符号（Analysis and Design Methods and Notations）

  分析和设计方法为我们提供的不仅仅是一种沟通媒介。它们允许我们构建模型并检查其完整性和一致性。
  		此外，我们可以更容易地重用以前项目中的需求和设计组件，从而相对轻松地提高生产力和质量。
  		但是，在确定一套通用的方法和工具之前，还有许多悬而未决的问题需要解决。我们需要确定建模原语，这将允许我们使用单个技术捕获问题的所有重要方面。
  		或者，我们需要开发一种可以用于所有方法的表示技术，可能以某种方式进行定制。

- 用户界面原型设计（User Interface Prototyping）

  原型设计（prototyping）意味着构建一个小版本的系统，通常功能有限，可以用于：
  帮助用户或客户确定系统的关键需求
  证明设计或方法的可行性
  		原型设计通常用于设计良好的用户界面（user interface）：用户与之交互的系统部分。然而，即使在嵌入式系统（embedded systems）中（即在用户无法明确看到软件功能的系统中），也有其他使用原型的机会。

- 软件体系结构（Software Architecture）

  系统的架构（architecture）用一组架构单元以及单元之间的关系图来描述系统。
  		单元越独立，体系结构就越模块化，我们就越容易单独设计和开发各个部分。

	- 模块分解（Modular Decomposition）

	  基于将功能分配给模块

	- 面向数据的分解（Data-Oriented Decomposition）

	  基于外部数据结构

	- 面向事件的分解（Event-Oriented Decomposition）

	  基于系统必须处理的事件

	- 由外而内设计（Outside-In Design）

	  基于用户对系统的输入

	- 面向对象设计（Object-Oriented Design）

	  基于识别对象类及其相互关系

- 软件过程（Software Process）

	- 企业或部门范围的应用程序（Enterprise- or Division-Wide Application）

		- 任务关键型（Mission-Critical）
		- 多用户（Multiuser）
		- 多平台（Multiplatform）
		- 2到3层开发（2- to 3-Tier Development）

	- 部门应用程序（Departmental Application）

		- 范围/视野有限（Limited Scope/Vision）
		- 低/中风险（Low/Medium Risk）
		- 单/多平台（Single/Multiplatform）
		- 1到2层开发（1- to 2-Tier Development）

	- 单用户桌面生产力工具（Single-user, Desktop Productivity Tool）

		- 包/最小开发（Packages/Minimal Development）
		- 低成本/低风险（Low Cost/Low Risk）
		- 单平台（Single Platform）

- 重用（Reuse）

	- 有时构建一个组件要比在可重用组件库中搜索一个更快
	- 使组件具有足够的通用性以便于重用可能需要额外的时间将来由其他开发人员开发
	- 很难记录已经完成的质量保证和测试的程度，以便潜在的重用者能够对组件的质量感到满意
	- 如果重用组件出现故障或需要更新，则不清楚由谁负责
	- 理解和重用其他人编写的组件可能既昂贵又耗时
	- 一般性和特殊性之间往往存在冲突

- 测量（Measurement）

  在较低的抽象级别上，度量有助于使我们的流程和产品的特定特性更加明显。将我们对真实、经验世界的理解转变为形式、数学世界中的元素和关系通常是有用的，在那里我们可以操纵它们以获得进一步的理解。
  		然后，这些新信息可以映射回现实世界，并作为我们试图解决的实证问题的解决方案的一部分加以应用。
  
  
  经验关系系统 	--测量-->	形式关系系统
  			/\									|
  			|		    				数学、统计学
  解决方案的实施						|
  			|									\/
  经验相关结果	  <--理解--	数字结果

	- 经验相关结果（Empirical, relevant results）
	- 经验关系系统（Empirical Relational System）
	- 形式关系系统（Formal Relational System）
	- 数字结果（Numeric Results）

- 工具和集成环境（Tools and Integrated Environments）

	- 平台集成（Platform Integration）

	  工具在异构网络上互操作的能力

	- 演示集成（Presentation Integration）

	  用户界面的通用性

	- 过程集成（Process Integration）

	  工具与开发过程之间的链接

	- 数据集成（Data Integration）

	  工具共享数据的方式

	- 控制集成（Control Integration）

	  一种工具通知另一种工具并在另一种工具中启动操作的能力

*XMind: ZEN - Trial Version*